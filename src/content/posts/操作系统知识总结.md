---
title: 操作系统知识总结
published: 2025-06-23
description: '本文总结了操作系统的相关知识点，包括内存管理，进程管理，磁盘管理，I/O管理，文件系统等'
image: ''
tags: []
category: '总结'
draft: false 
lang: ''
---


### 操作系统的功能

用户和计算机硬件之间的接口，操作系统作为资源管理器，实现了对计算机资源的扩充。

### 操作系统有几个模块

进程调度，内存管理，磁盘管理，I/O设备管理，文件系统

### 操作系统的发展

串行处理（此时还没有操作系统）-> 简单批处理系统（出现操作系统） -> 多道批处理系统 -> 分时系统

简单批处理：监控程序在一个作业完成后会读取下一个作业

多道批处理：内存空间够大，当一个作业需要等待I/O，处理器可以切换到另一个不在等待io的作业，批处理没有中断，交互。

分时系统：多个用户可以通过终端同时访问系统，操作系统控制每个用户程序在很短的时间内交替执行。

###  分时系统和批处理系统的概念产生背景和对比。

多道批处理为了充分利用处理器（等待io花费时间过长），使用作业控制语言命令和作业提供的命令作为OS指令源。分时系统为了减小响应时间（当时计算机庞大且昂贵，需要多个用户分享处理器时间），使用终端键入的命令作为OS指令源。

### 中断和异常，在批处理和分时系统当中起到什么作用？简单一句话就是把控制权收回来，那么系统里是怎么收回的，分时系统是怎么收回来。

执行流程控制，资源保护，多任务调度

发生中断或异常时，运行用户态的CPU会立即进入内核态，通过硬件实现

中断（外中断）：IO，到达固定时间片等；异常（内中断）：系统调用，程序非法操作码，地址越界，缺页，溢出等。

批处理系统靠程序执行完或I/O等中断被动收回控制权；分时系统靠定时器中断主动定时收回控制权，进行任务轮换。

### 为了实现进程，CPU需要提供哪些硬件支持

* 程序计数器（PC）
* 处理器寄存器
* 支持内存管理
* 实现中断机制
* 支持用户态到内核态的转变，实现系统调用

### 什么叫进程，进程跟程序的区别。

进程的两个基本元素是**程序代码**和与代码相关联的**数据集**。

进程是一个正在计算机上执行的程序实例，是能分配给处理器并由处理器执行的实体。一个程序可以启动多个进程。程序是静态的，存储在磁盘上的。进程是动态的，进程的状态会发生变化。

### 进程控制块的概念。进程控制块里面有最关键的几个字段

* 标识符：与进程相关的唯一标识符，用来区分其他进程
* 状态：表示进程此时的状态
* 优先级：相对于其他进程的优先顺序
* 程序计数器：程序中即将执行的下一条程序的地址
* 内存指针：包括程序代码和进程相关数据的指针

### 进程的生命周期，进程的几个构成要素

进程的生命周期包括创建、就绪、运行、阻塞和终止五个基本状态，通过调度、中断等在这些状态间转换。

构成要素：代码段，数据段，BSS段（存放未初始化的全局变量和静态变量），堆，栈，进程控制块。

### 进程的常见的系统调用有哪些？进程创建、销毁、阻塞和通讯

进程创建：分配唯一进程标识符，分配空间，初始化进程控制块，设置正确链接（调度队列的链表）

进程切换：可在操作系统从当前正运行进程中获得控制权的任何时刻发生。

保存处理器上下文（包括PC和其他寄存器的值），更新当前处于运行态的进程控制块，移到相应队列，选择另一个进程执行，更新所选进程的PCB，更新内存管理数据结构，载入保存的PC和其他寄存器之前的值。

### 进程的五状态图，七状态图

图略

### 进程的切换，语态的切换和 CPU状态的切换。三个切换：进程的切换，进程状态的切换，CPU状态的切换

进程的切换，是指操作系统将当前正在运行的进程挂起，转而调度另一个就绪进程运行的过程。此过程是由调度器在特定条件下触发的，比如当前进程时间片耗尽、发生 I/O 请求、或有更高优先级的进程需要运行。切换时，操作系统必须保存当前进程的 CPU 状态到其 PCB（进程控制块）中，并从目标进程的 PCB 中恢复相应内容。这一过程代价较高，因为涉及频繁的内存读写和权限转换。

进程状态的切换是指进程在其生命周期中，由一个状态转移到另一个状态的过程。典型的状态包括新建、就绪、运行、阻塞、退出等。进程状态的变化反映的是进程对系统资源的使用情况及其是否具备运行条件。例如，进程开始执行后需要等待某个 I/O 结果，它就从运行状态变为阻塞状态；当 I/O 完成后，它再从阻塞变为就绪。状态的变化并不一定意味着进程获得或失去了 CPU，比如从就绪到阻塞的变化，是逻辑上的状态转移，而不是物理上的 CPU 切换。

CPU 状态的切换描述的是 CPU 自身在执行权限和控制模式上的转换，主要包括用户态和内核态之间的切换。用户态是进程正常运行时所处的状态，受限于指令权限；内核态则是操作系统执行系统调用、中断服务等关键操作时所处的高权限状态。当进程发起系统调用，或外部中断（如时钟中断、设备中断）和异常发生时，CPU 会从用户态切换到内核态，以处理这些请求。处理完毕后，再切换回用户态继续执行进程代码。此外，当系统中没有可运行的进程时，CPU 还可能进入空闲状态，这也是一种执行状态的转变。


### 进程创建的流程的具体描述，以linux为例，fork函数

分配唯一进程标识符，分配空间，初始化进程控制块，设置正确链接

完成以上操作后，操作系统将新创建的进程状态设置为就绪，并将其加入就绪队列，等待调度器选择合适的时间将其调度到 CPU 上执行。从此，新进程就正式加入了系统的调度循环，成为可独立运行的执行实体。

最后，控制权会返回给原始进程（父进程），它可以获得新进程的 PID，并根据需要进行后续管理。

### 线程的含义，进程和线程的区别，线程的三种实现方法，ult和blkt它们之间的对比，各自的优缺点是什么？

线程是程序执行中的最小单位，在一个进程内部可以并发地存在多个线程。线程共享进程的资源，例如代码段、数据段、打开的文件和地址空间，但每个线程拥有自己的堆栈空间和寄存器上下文。线程之间的切换开销比进程小，创建速度更快。

**进程是资源分配的最小单位，而线程是程序执行调度的最小单位。**

进程具有独立的地址空间和系统资源，而线程则是运行在进程内部、共享其资源的多个执行流。

进程和线程的区别：

* 资源独立性：进程之间彼此独立，一个进程崩溃不会影响其他进程；而线程之间依赖于所属进程，共享数据空间，一个线程的错误（如指针越界）可能会影响整个进程。
* 上下文切换开销：进程切换需要保存和恢复完整的进程状态，包括内存映射、文件描述符、寄存器等，开销较大；线程切换只需保存最小的上下文信息，因此更加高效。
* 通信方式：进程间通信需借助操作系统提供的机制，如管道、共享内存、消息队列等；而线程之间共享内存地址空间，可以直接读写数据，通信更加快捷。
* 应用角度来看，进程更适合执行相互独立、隔离性强的任务，例如运行不同的程序或服务，而线程适用于需要并行执行、共享数据的任务，如并发请求处理、GUI 事件响应等。多线程程序可以充分利用多核处理器资源，提高执行效率，但也需要开发者精心设计同步机制以避免竞争条件和死锁。

### 用户级线程（ULT），内核级线程（KLT）

用户级线程（ULT）

用户级线程是完全由用户空间的线程库实现和管理的线程，操作系统内核对此并不感知。在这种模型下，线程的创建、销毁、调度和同步等操作均由线程库负责，无需进行系统调用。

ULT 的一个显著优点是线程操作效率高，因为上下文切换不涉及内核，不需要陷入内核态，速度非常快。同时，不依赖操作系统支持，便于移植。例如某些嵌入式系统或简单操作系统中并不支持内核级线程，使用用户线程可以实现并发。

但 ULT 也存在重要的缺陷：一个线程阻塞会导致整个进程阻塞。由于内核无法感知线程的存在，它只认为是单个进程在运行。如果一个线程执行了阻塞性系统调用（如读文件或等待 I/O），整个进程就会被挂起，从而影响其他线程的并发执行。

内核级线程（KLT）

内核级线程由操作系统内核直接支持和管理。每个线程在内核中都有一个对应的数据结构，内核可以直接调度线程而非整个进程。KLT 的调度与切换完全由操作系统负责，并通过系统调用进行控制。

KLT 的优势在于真正实现了并发执行，即便某个线程被阻塞，内核也可以调度同一进程内的其他线程继续运行，从而提高资源利用率。此外，KLT 可以充分利用多核处理器，操作系统可以将多个线程调度到不同的 CPU 上并行执行。

KLT 的缺点是开销大。线程的创建、销毁、切换都需要系统调用，频繁的用户态和内核态切换会影响性能。此外，不同操作系统对 KLT 的支持差异较大，移植性不如 ULT。

### 并发需要解决的四个问题

* 同步是指多个进程或线程在执行过程中需要按照一定的时序关系协同进行，以保证共享资源的一致性和操作的有序性。
* 互斥是同步的一种特殊情况，指的是多个线程/进程在访问临界资源时，必须互斥地进入，即任意时刻只能有一个执行实体访问该资源，以防止竞争条件和数据不一致。
* 饥饿是指某个进程或线程长时间得不到所需资源而无法推进执行，尽管其他进程/线程不断完成任务。
* 死锁是指两个或多个进程在执行过程中，因争夺资源而导致彼此互相等待、永不推进的状态。

### 什么是条件竞争，并举例

条件竞争是指两个或多个进程或线程并发访问共享资源，并且程序的正确性依赖于它们的执行顺序，但这种顺序是不可预测的，从而导致不确定的、错误的运行结果。

### 什么叫临界区？临界区域的构成，每一个部分大概起什么作用？

临界区是指一段访问共享资源的代码区域。

| 部分 | 名称                            | 作用                                                         |
| ---- | ------------------------------- | ------------------------------------------------------------ |
| 1    | **进入区（Entry Section）**     | 尝试进入临界区之前执行的代码，用来请求进入临界区。<br>实现互斥的机制就在这里，比如加锁、P操作、flag判断等。 |
| 2    | **临界区（Critical Section）**  | 实际访问共享资源的那段代码，必须互斥执行。                   |
| 3    | **退出区（Exit Section）**      | 离开临界区后执行的代码，负责释放锁或做出标记，允许其他进程进入。 |
| 4    | **剩余区（Remainder Section）** | 不涉及共享资源的普通代码，所有进程都可以自由执行。           |

### 解决同步互斥的方法

Dekker算法：复杂的程序很难实现且其正确性也很难证明

Peterson算法：......

信号量：一种用于进程或线程间实现同步与互斥的原语，它是一种基于计数器的机制，由操作系统或线程库提供，用于控制多个执行实体对共享资源的访问。

管程：管程是一种高级同步原语，它将共享资源及其操作封装在一个程序模块（或对象）中，并由系统保证任一时刻最多只有一个进程或线程在执行其中的操作。

消息传递：消息传递是通过 send（发送） 和 receive（接收） 原语，实现在并发环境中两个或多个进程之间的通信方式。

硬件方法：**中断禁用**，用于单处理器，在使用临界区时禁用中断。**专用机器指令**，在硬件级别上，对存储单元的访问排斥对相同单元的其他访问。

### 进程间的关系有几种，简述关系以及产生原因

互斥或同步

互相不知道对方的存在：关系是竞争。这些进程不会一起工作，但OS需要知道它们对资源的竞争情况。产生原因：独立运行的程序之间。互斥，死锁（可重用资源），饥饿

间接知道对方存在：关系是通过共享合作。不需要知道对方进程的ID，但共享某些对象，如IO缓冲区。产生原因：这些进程之间通过某些共享资源，如共享内存、文件、缓冲区等间接协作。互斥，死锁（可重用资源），饥饿，数据一致性

直接知道对方的存在：关系是通信合作。进程可通过ID相互通信。产生原因：进程之间直接通信与协作。死锁（可消耗资源），饥饿

### 什么叫管程，管程的构成，管程的产生背景，管城和信号量对比有什么优缺点

管程是一种高级同步原语，用于在并发程序中对共享资源进行安全、结构化的访问控制。它将共享数据、对数据的操作过程、同步机制封装在一起，使并发访问更有序、更安全。本质上是一种语言级的抽象，把共享资源、操作过程、以及同步机制封装在一起的结构。

构成：管程的名称，局部于管程内部的共享数据结构，对该数据结构进行操作的一组函数，对局部于管程内部的共享数据结构设置初始值的语句。

内部的数据和变量只有管程可以访问，进程只能通过管程内部的方法访问管程内部数据，每次只有一个进程通过管程内部方法访问管程。

信号量虽然功能强大但易出错，容易造成死锁、资源泄露等问题

| 对比方面        | 管程                                                         | 信号量                                                       |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 抽象层级        | 高级同步机制，结构化、模块化                                 | 低级同步机制，编程自由度高                                   |
| 使用方式        | 自动互斥，调用管程内过程即获得锁                             | 需要手动调用 P() / V()（或 wait() / signal()）来获取/释放信号量 |
| 错误风险        | 低，互斥逻辑内嵌于管程内部                                   | 高，容易因忘记释放信号量或不当使用造成死锁                   |
| 可读性/可维护性 | 高，封装明确，过程清晰                                       | 低，逻辑分散、维护困难                                       |
| 灵活性          | 相对较低，约束较强                                           | 高，可实现复杂同步逻辑                                       |
| 调度策略        | Hoare 管程：立即唤醒等待者并切换；Mesa 管程：唤醒后等待者重新尝试 | 无强制调度策略，依赖程序控制                                 |
| 使用场景        | 多用于高级语言（如 Java、C++11）中的线程同步，如 synchronized、条件变量等；常用于操作系统设计中的进程同步模型 | 更偏向底层实现，如内核中的设备同步、驱动程序、系统调用级别的同步 |

### 死锁的概念，死锁的条件，死锁的解决方法，死锁的避免检测预防和恢复

死锁：当一组进程都在等待某一事件，但这个事件只有这组进程中被阻塞的其他进程才可以触发，就称这组进程发生了死锁

三个必要条件：互斥，占有且等待，不可抢占。

**上面三个条件加上“循环等待”，这四个一起构成了死锁的充分必要条件。**

死锁预防：设置限制条件，破坏4个条件中的一个或几个。允许资源共享使用。可抢占（常用于状态易于保存和恢复的资源）。破坏占有且等待（要求程序在运行时不能持有不可剥夺资源），预先分配所有资源或只获得运行初期所需的资源，逐步释放已使用的资源后才可申请新的资源。顺序资源申请顺序

死锁避免：**银行家算法**

死锁检测：死锁检测算法，**死锁检测算法检测出来的不一定会发生死锁。**

死锁避免允许三个必要条件，但通过明智的选择，保证永远不会到达死锁点，因此死锁避免可以允许更多的并发

死锁避免的优点是无需死锁预防中的抢占和进程回滚，限制较少。但也有限制：进程必须实现声明请求的最大资源数量，进程间的执行顺序没有任何同步要求的限制，分配资源的数量必须是固定的，在占有资源时，进程不能退出

### 银行家算法，银行家算法的主要思想是什么？能不能解决，或是不是能彻底解决死锁的问题。

在资源分配前，先进行安全性检测，只有当系统处于“安全状态”时才进行资源分配，否则拒绝请求。

### 内存管理的7类方法

固定分区，动态分区，简单分页，简单分段，虚拟分页，虚拟分段，虚拟分段+分页。

### 虚拟存储需要考虑的三个问题，书上的一句话，在第二百二十五页。

* 内存空间不足问题：虚拟存储器可以将未被使用的数据和程序存放在磁盘上，从而释放内存空间，以满足正在运行的程序的内存需求。
* 地址映射问题：虚拟存储器需要解决虚拟地址到物理地址的映射问题。当程序需要访问某个虚拟地址时，虚拟存储器需要将该虚拟地址映射到物理地址上。
* 页面置换问题：当物理内存空间不足时，虚拟存储器需要将⼀部分暂时不需要的页面置换到磁盘上，以便为新的页面腾出空间。虚拟存储器需要设计合理的页面置换算法，以提高系统性能和效率。

### 虚拟内存的实现的三个方法，简述方法的特点。什么是虚拟分段、虚拟分页？

第三个千万不要写错了，虚拟分段加分段，而不是分页加分段

* 分页：将物理内存和虚拟内存划分为固定大小的页，通过页表映射虚拟页到物理页帧。支持非连续分配，消除外部碎片，但可能存在内部碎片。
* 分段：按逻辑单元（如代码、堆、栈）划分可变长度的段，每段独立映射到物理内存。
* 段页式：先按逻辑分段，每段再划分为固定页，通过段表和页表两级映射。
* 虚拟分段：虚拟地址由段号+段内偏移组成，段长度可变，映射到物理内存的任意区域。优点：逻辑性强，便于共享和保护；缺点：外部碎片严重。
* 虚拟分页：虚拟地址划分为固定大小的页，页号映射到物理页帧，页内偏移直接使用。优点：无外部碎片，管理简单；缺点：缺乏语义信息，内部碎片可能浪费空间。

![16](https://raw.githubusercontent.com/Aur0r3-zy/picture/main/img/20250624185335187.png)

**为什么没有页段式？？？**

### 页故障的处理流程，书上也有一段话，书上的原则话，把这段话整理一下写上来，最好画个图。

产生缺页中断，进程阻塞，若有空闲页框，则装入。否则执行页面置换算法选择页面进行淘汰，淘汰的页面若修改过，还需要写回外存。

* 判断是否是访问了非法地址，如果是，则杀死进程。
* 判断是否是访问了合法但未被分配的地址，如果是，则分配⼀个新的物理页面，并将磁盘中对应的页面读入到该物理页面中。
* 判断是否是访问了已经被分配但未在内存中的地址，如果是，则将磁盘中对应的页面读入到空闲的物理页面中，并更新页表中的映射关系。
* 判断是否是访问了已经被分配且在内存中的地址，但该页面被标记为脏页，即该页面被修改过但还没有写回到磁盘中。如果是，则需要先将该页面写回到磁盘中，然后再将磁盘中对应的页面读入到空闲的物理页面中，并更新页表中的映射关系。

### 长、中、短，三个调度的概念

长程调度：决定哪个程序可以进入系统中处理，内存与辅存之间的调度，从外存的后备队列挑选，对其分配内存等必要资源，并建立相应进程，以使他们获得竞争CPU的权利。每个作业只调入一次，调出一次。

中程调度：挂起态，如果再次具备运行条件且内存空闲，调入内存。

短程调度：按照算法从就绪队列中选取一个进程，将CPU分配给他。

### 不同进程调度算法之间的一个对比，性能对比，公平性对比，公平性里面最主要的是会不会产生饥饿。

优先级不同：先入先出队列的优先级调度：维护多个优先级队列，低优先级可能出现饥饿。

优先级相同：

* 非抢占式：先来先服务（FCFS），不会出现饥饿，但会偏向运行时间较长和CPU繁忙型的进程。最短进程优先（SPN），选择准备队列中所需服务时间最小的进程，对长作业不利，可能导致饥饿。实际中很难预测一个进程的执行时间，可以达到理论最优。最高响应比优先（HRRN），公式
* 抢占式：时间片轮转（RR）。最小剩余时间优先（SRT），是SPN的抢占式版本，选择剩余执行时间最短的进程进行执行，偏向短进程。多级反馈队列，MLFQ偏向短进程，长进程连续降级，可能导致饥饿，SPN，SRT和多级反馈队列可能导致饥饿

### 单buffer，双bufer，循环buffer

设备将一块数据输入到缓冲区：T；OS将数据从缓冲区送到工作区：M；CPU处理数据：C。

单缓冲：$Max(T，C)+M$

双缓冲：$Max(C+T，M)$

### 磁盘调度算法

磁盘调度算法：先来先服务（FCFS），公平简单；最短寻道时间优先（SSTF）：每次调度距离当前磁头0最近的磁道（可能导致饥饿）；扫描算法（电梯算法）（SCAN）不利于远离磁头一侧的访问请求；循环扫描算法（C-SCAN）：严格遵循从一端到另一端。 都是非抢占式

### 文件系统的设计层次

<img src="https://raw.githubusercontent.com/Aur0r3-zy/picture/main/img/20250624185951240.png" alt="图片1" style="zoom:50%;" />

### 文件系统逻辑层

堆文件：按照到来顺序存储，不定长，插入简单，但要穷近式搜索

顺序文件：记录定长，有一个关键域用来标识记录

索引顺序文件：为顺序文件添加索引，索引顺序文件只为一个关键域建立索引

索引文件：为了实现通过每个域，而非关键域，都可以进行查找。完全索引，包含所有记录的索引值；部分索引，只包含那些有感兴趣域的记录的索引值

直接/散列文件：文件由定长记录构成，每个记录由确定顺序的、定长的域构成，具有一个关键域用以唯一标识每个记录，记录采用散列表索引，不按照关键域排序，更新和检索单个记录容易，否则需要穷尽法

### 文件系统物理层

连续分配：

链式分配：

基于块的索引分配：

基于可变长度分区的索引分配：

### 文件分配表中分区的大小在设计上需要考虑哪些因素？是不是可变，应该多大多小，太大的也不好，太小的也不好，是不是连续等。

在设计块或簇的大小时，首先需要考虑磁盘的总容量。容量越大，为了减少文件分配表的尺寸，往往需要增大每个簇的大小。否则，如果使用较小的簇，每个文件就可能需要更多簇，导致 FAT 表项数剧增，占用大量内存和存储空间，降低效率。另一方面，文件的平均大小也必须纳入考虑。如果系统中主要存储的是大量小文件，簇不宜太大，否则会导致“内部碎片”严重，也就是每个小文件都浪费了簇中未使用的空间。

块大小还影响磁盘的 I/O 性能和寻址开销。较大的块可以减少寻址次数，提高顺序读写效率，但不利于频繁的随机访问和对小文件的处理。反之，较小的块虽然更灵活，也有利于空间利用，但文件系统必须维护更多的块信息，从而增大 FAT 表或 inode 表的规模，增加管理开销。特别是在链式分配或索引分配中，块越小，链表越长或索引结构越复杂，对系统资源要求越高。

至于是否要求连续分配，这取决于所采用的分配策略。在连续分配中，系统必须预留一整块连续的磁盘空间来保存一个文件，对碎片敏感，适合顺序访问但灵活性差。而在链式分配和索引分配中，文件可以分布在磁盘上的任意位置，不需要连续，因此块可以较小，提高灵活性和空间利用率，但也带来了更复杂的管理逻辑和更多的寻址开销。

### 文件分配表中（物理层），连续分配和链式分配，那么存在哪些不足，怎么来解决

**实现互斥需要满足下列哪些要求:( )**
A. 一次只允许一个进程进入临界区
B. 一个进程驻留在临界区中的时间必须是有限的
C. 对相关进程的执行速度没有任何要求和限制
D. 以上都是
正确答案:D:以上都是;

**生产者/消费者问题不能视为一个的特殊读者/写者问题的原因是:( )**
A. 生产者/消费者各自一个,而读者/写者各自可以有多个
B. 生产者和消费者其实同时是读者和写者
C. 当写者执行写入的时候,读者也可以执行读取;而生产者/消费者不同
D. 以上都不是
正确答案:B

**在死锁进程恢复中,选择一个特定进程中止或回滚的选择标准包括:( )**
A. 到目前为止分配的总资源最少
B. 最低优先级
C. 预计剩余时间最长
D. 以上都是
正确答案:D:以上都是;

**一个正在访问临界资源的进程由于申请等待I/O操作而被中断时，它（   ）**

- A. 允许其他进程进入与该进程相关的临界区
- B. 不允许其他进程进入任何临界区
- C. 允许其他进程抢占处理器，但不得进入该进程的临界区
- D. 不允许任何进程抢占处理器

*答案:*C

**在系统运行过程中，通过检查系统是否处于安全状态而不让死锁发生的策略是（ ）**

- A. 死锁预防
- B. 死锁避免
- C. 死锁检测
- D. 死锁解除

*答案:*B:死锁避免;

**下列描述的各种现象中，属于活锁现象的是**

- A. 相关进程进入阻塞状态，且无法唤醒
- B. 相关进程进入阻塞状态，且可以唤醒
- C. 相关进程没有阻塞，但是调度时刻被延迟推后
- D. 相关进程没有被阻塞，可被调度，但是不做有用的工作

*正确答案:*D:相关进程没有被阻塞，可被调度，但是不做有用的工作;

**下面关于安全状态和非安全状态说法正确的是(  )**

- A. 安全状态是没有死锁的状态，非安全状态是有死锁的状态
- B. 安全状态是可能有死锁的状态，非安全状态也可能有死锁状态
- C. 安全状态是可能没有死锁的状态，非安装状态有死锁的状态
- D. 安全状态没有死锁的状态，非安全状态可能有死锁的状态

*正确答案:*D:安全状态没有死锁的状态，非安全状态可能有死锁的状态;

**在进程资源图中(  )是发生死锁的必要条件。**

- A. 互斥
- B. 可剥夺条件
- C. 环路
- D. 同步

*正确答案:*A:互斥;

**死锁预防的一种直接方法是防止以下哪些情况的发生:(   )**

- A. 占有且等待
- B. 互斥
- C. 循环等待
- D. 以上都是

*正确答案:*D:以上都是;

**将程序和数据组织起来,使不同的模块分配到同一内存区域的做法称为:( )**

- A. 共享/Sharing
- B. 重定位/Location
- C. 覆盖/Overlay
- D. 以上都不是

*正确答案:*C

**在采用固定分区内存管理方案的系统中,内部碎片的问题可以通过以下哪种方法得到缓解:( )**
A. 随机大小的分区
B. 大小不等的分区
C. 大小相等的分区
D. 以上都不是
正确答案:B:大小不等的分区;

**进程的页表内所维护的地址是:( )**
A. 进程中每一页/page的页框/frame地址
B. 进程中每个页框/frame的页/page地址
C. 每个进程的虚拟内存地址
D. 以上都不是
正确答案:A:进程中每一页/page的页框/frame地址;

**操作系统采用分页式存储管理(Paging)方法，要求( )**

- A. 每个进程拥有一张页表，且所有进程的页表必须驻留在内存中
- B. 每个进程拥有一张页表，但只有执行进程的页表驻留在内存中，其他进程的页表不必驻留在内存中
- C. 所有进程共享一张页表，以节约有限的内存空间，但页表必须驻留在内存中
- D. 所有进程共享一张页表，只有页表中当前使用的页面必须驻留在内存中，以最大限度地节约有限的内存空间

*正确答案:*B:每个进程拥有一张页表，但只有执行进程的页表驻留在内存中，其他进程的页表不必驻留在内存中;

**为了实现多道程序设计，计算机需要比单道更( )**

- A. 大的内存
- B. 快的外部设备
- C. 快的CPU
- D. 先进的终端

*正确答案:*A:大的内存;

**虚拟页式管理中的(  )是：当内存中没有空闲帧时，如何将已占据的帧释放**

- A. 调入策略
- B. 地址变换
- C. 替换策略
- D. 调度算法

*正确答案:*C:替换策略;

**当内存碎片容量大于某一作业所申请的内存容量时，(  )**

- A. 可以为这一作业分配内存
- B. 不可以为这一作业分配内存
- C. 拼接后，可以为这一作业分配内存
- D. 一定能够为这一作业分配内存

*正确答案:*D:一定能够为这一作业分配内存;

**(    )是指让作业不同时调用的子模块共同使用同一个内存区。**
A. 交换技术
B. 覆盖技术
C. 物理扩充
D. 虚拟扩充技术
我的答案:B:覆盖技术;正确答案:B:覆盖技术;

**某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为 $2^{10}$ B，页表项大小为2B，逻辑地址结构为逻辑地址空间大小为$2^{16}$页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是（ ）**

![img](https://raw.githubusercontent.com/Aur0r3-zy/picture/main/img/20250619011856262.png)

- A. 64
- B. 128
- C. 256
- D. 512

*正确答案:*B:128;

**与决定驻留在主存中的进程数相关的概念被称为:( )**

- A. 页面错误频率
- B. 加载控制
- C. 清除策略
- D. 以上都不是

*正确答案:*B:加载控制;

**在分段系统中,共享通过什么实现的:( )**

- A. 一个所有进程共享的公共数据存储区
- B. 每个进程的段表都有一个对主存区域调度程序的引用
- C. 在两个及两个以上的进程中引用段表中的同一个段
- D. 以上都是

*正确答案:*C

**段页式管理每取一数据，要访问(  )次内存。**

- A. 1
- B. 2
- C. 3
- D. 4

*正确答案:*C:3;

**对于虚拟存储器的分页系统，对于驻留集（Resident Set）管理，有两个维度：其一是固定或者可变分配；其二是局部或者全局分配。综合（即组合）起来，理论上，有2*2=四种可能性，但实际上，有一种实际上是不存在的，它是：**

- A. 固定分配 & 局部分配
- B. 固定分配 & 全局分配
- C. 可变分配 & 局部分配
- D. 可变分配 & 全局分配

*正确答案:*B:固定分配 & 全局分配;

**下列选项中，通过不需要系统调用就能完成的操作是（）**

- A. 释放内存
- B. 页置换
- C. 创建新进程
- D. 进程间信号传递

*我的答案:*B:页置换;*正确答案:*B:页置换;

**段式虚拟存储器的最大容量是(  )**

- A. 由计算机地址结构长度决定的
- B. 由段表的长度决定的
- C. 由内存地址寄存器的长度决定的
- D. 无穷大的

*正确答案:*A

**有一虚拟存储系统，若进程在内存中占3页(开始时内存为空)，若采用先进先出(FIFO)页面淘汰算法，当执行如下访页页号序列后1，2，3，4，1，2，5，1，2，3，4，5，会产生(  )次缺页。**

- A. 7
- B. 8
- C. 9
- D. 10

*正确答案:*C:9;

**内存和外存容量之和与虚拟存储器容量相比其大小关系是( )**

- A. 前者比后者大
- B. 前者比后者小
- C. 二者相等
- D. 不一定

*正确答案:*D:不一定;

**在批处理系统中，周转时间的定义是(   )**
A. 进程的实际运行时间
B. 进程的等待时间和运行时间之和
C. 进程的等待时间
D. 进程被调度进入内存到运行完毕的时间
正确答案:D:进程被调度进入内存到运行完毕的时间;

**直接或散列文件通常( ):**

- A. 一次只访问一条记录
- B. 记录长度是固定的
- C. 要求快速访问时使用
- D. 以上都是

*正确答案:*D:以上都是;

**文件目录哪个信息单元,包含了文件创建者的身份等信息(  ):**

- A. 使用信息
- B. 地址信息
- C. 访问控制信息
- D. 以上都是

*正确答案:*A:使用信息;

**若一个用户进程通过read系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是（ ）a.若该文件的数据不在内存，则该进程进入睡眠等待状态b.请求read系统调用会导致CPU从用户态切换到核心态c.read系统调用的参数应包含文件的名称**

- A. a, b
- B. a, c
- C. b, c
- D. a, b, c

*正确答案:*A:a, b;

**关于连续分配，下列说法错误的是？**

- A. 连续分配方法是给每个文件分配一段连续的变长分区
- B. 每个文件只需要一个FAT表项
- C. 连续分配方式的局部性好，且利用率和分配灵活度高
- D. 可以使用压缩(compaction)以减少外部碎片

*正确答案:*C:连续分配方式的局部性好，且利用率和分配灵活度高;

**某文件用作主文件，要求对此文件既能顺序访问，又能随机访问，下列各种形式中最适合的文件形式是( )**

- A. 顺序文件
- B. 索引顺序文件
- C. 直接文件
- D. Hash文件

*正确答案:*B:索引顺序文件;